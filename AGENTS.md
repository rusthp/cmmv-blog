<!-- RULEBOOK:START -->
# Project Rules

Generated by @hivellm/rulebook
Generated at: 2025-11-01T07:16:54.252Z

<!-- QUALITY_ENFORCEMENT:START -->
# Quality Enforcement Rules

**CRITICAL**: These rules are NON-NEGOTIABLE and MUST be followed without exception.

## Absolute Prohibitions

### Test Bypassing - STRICTLY FORBIDDEN
- NEVER use .skip(), .only(), or .todo() to bypass failing tests
- NEVER comment out failing tests
- NEVER use @ts-ignore, @ts-expect-error, or similar to hide test errors
- NEVER mock/stub functionality just to make tests pass without fixing root cause
- FIX the actual problem causing test failures

### Git Hook Bypassing - STRICTLY FORBIDDEN  
- NEVER use --no-verify flag on git commit
- NEVER use --no-verify flag on git push
- NEVER disable or skip pre-commit hooks
- NEVER disable or skip pre-push hooks
- FIX the issues that hooks are detecting

### Test Implementation - STRICTLY FORBIDDEN
- NEVER create boilerplate tests that don't actually test behavior
- NEVER write tests that always pass regardless of implementation
- NEVER write tests without assertions
- NEVER mock everything to avoid testing real behavior
- WRITE meaningful tests that verify actual functionality

### Problem Solving Approach - REQUIRED
- DO NOT seek the simplest bypass or workaround
- DO NOT be creative with shortcuts that compromise quality
- DO solve problems properly following best practices
- DO use proven, established solutions from decades of experience
- DO fix root causes, not symptoms

## Enforcement

These rules apply to ALL implementations:
- Bug fixes
- New features  
- Refactoring
- Documentation changes
- Any code modifications

**Violation = Implementation Rejected**

<!-- QUALITY_ENFORCEMENT:END -->


## Documentation Standards

**CRITICAL**: Minimize Markdown files. Keep documentation organized.

### Allowed Root-Level Documentation
Only these files are allowed in the project root:
- ‚úÖ `README.md` - Project overview and quick start
- ‚úÖ `CHANGELOG.md` - Version history and release notes
- ‚úÖ `AGENTS.md` - This file (AI assistant instructions)
- ‚úÖ `LICENSE` - Project license
- ‚úÖ `CONTRIBUTING.md` - Contribution guidelines
- ‚úÖ `CODE_OF_CONDUCT.md` - Code of conduct
- ‚úÖ `SECURITY.md` - Security policy

### All Other Documentation
**ALL other documentation MUST go in `/docs` directory**:
- `/docs/ARCHITECTURE.md` - System architecture
- `/docs/DEVELOPMENT.md` - Development guide
- `/docs/ROADMAP.md` - Project roadmap
- `/docs/DAG.md` - Component dependencies (DAG)
- `/docs/specs/` - Feature specifications
- `/docs/sdks/` - SDK documentation
- `/docs/protocols/` - Protocol specifications
- `/docs/guides/` - Developer guides
- `/docs/diagrams/` - Architecture diagrams
- `/docs/benchmarks/` - Performance benchmarks
- `/docs/versions/` - Version release reports

## Testing Requirements

**CRITICAL**: All features must have comprehensive tests.

- **Minimum Coverage**: 95%
- **Test Location**: `/tests` directory in project root
- **Test Execution**: 100% of tests MUST pass before moving to next task
- **Test First**: Write tests based on specifications before implementation

## Feature Development Workflow

**CRITICAL**: Follow this workflow for all feature development.

1. **Check Specifications First**:
   - Read `/docs/specs/` for feature specifications
   - Review `/docs/ARCHITECTURE.md` for system design
   - Check `/docs/ROADMAP.md` for implementation timeline
   - Review `/docs/DAG.md` for component dependencies

2. **Implement with Tests**:
   - Write tests in `/tests` directory first
   - Implement feature following specifications
   - Ensure tests pass and meet coverage threshold

3. **Quality Checks**:
   - Run code formatter
   - Run linter (must pass with no warnings)
   - Run all tests (must be 100% passing)
   - Verify coverage meets threshold

4. **Update Documentation**:
   - Update `/docs/ROADMAP.md` progress
   - Update feature specs if implementation differs
   - Document any deviations with justification

## Rules Configuration

Rules can be selectively disabled using `.rulesignore` file in project root.

Example `.rulesignore`:
```
# Ignore coverage requirement
coverage-threshold
# Ignore specific language rules
rust/edition-2024
# Ignore all TypeScript rules
typescript/*
```

<!-- RULEBOOK:END -->


<!-- TYPESCRIPT:START -->
# TypeScript Project Rules

## Agent Automation Commands

**CRITICAL**: Execute these commands after EVERY implementation (see AGENT_AUTOMATION module for full workflow).

```bash
# Complete quality check sequence:
npm run type-check        # Type checking
npm run lint              # Linting (0 warnings required)
npm run format            # Code formatting  
npm test                  # All tests (100% pass required)
npm run test:coverage     # Coverage check (95%+ required)
npm run build             # Build verification

# Security audit:
npm audit --production    # Vulnerability scan
npm outdated              # Check outdated deps (informational)
```

## TypeScript Configuration

**CRITICAL**: Use TypeScript 5.3+ with strict mode enabled.

- **Version**: TypeScript 5.3+
- **Mode**: Strict mode enabled
- **Target**: ES2022 or later
- **Module**: ESNext with Node16 module resolution

### tsconfig.json Requirements

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order.

**IMPORTANT**: These commands MUST match your GitHub Actions workflows to prevent CI/CD failures!

```bash
# Pre-Commit Checklist (MUST match .github/workflows/*.yml)

# 1. Type check (matches workflow)
npm run type-check  # or: tsc --noEmit

# 2. Lint (MUST pass with no warnings - matches workflow)
npm run lint

# 3. Format check (matches workflow - use same command as CI)
npx prettier --check 'src/**/*.ts' 'tests/**/*.ts'

# 4. Run all tests (MUST pass 100% - matches workflow)
npm test

# 5. Build (MUST succeed - matches workflow)
npm run build

# 6. Check coverage (MUST meet threshold)
npm run test:coverage
```

**If ANY of these fail, you MUST fix the issues before committing.**

**Why This Matters:**
- Running different commands locally than in CI causes "works on my machine" failures
- CI/CD workflows will fail if commands don't match
- Example: Using `prettier --write` locally but `prettier --check` in CI = failure
- Example: Forgetting `npm run build` locally = CI build failures

### Linting

- Use ESLint with TypeScript plugin
- Configuration in `eslint.config.js` or `.eslintrc.json`
- Must pass with no warnings: `eslint src/**/*.ts`
- Fix automatically when possible: `eslint src/**/*.ts --fix`

Example ESLint config:
```json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "warn"
  }
}
```

### Formatting

- Use Prettier for code formatting
- Configuration in `.prettierrc.json`
- Integrate with ESLint for consistency
- Format before committing: `prettier --write "src/**/*.ts"`

Example Prettier config:
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}
```

### Testing

- **Framework**: Vitest (recommended) or Jest
- **Location**: `/tests` directory or co-located `*.test.ts` files
- **Coverage**: Must meet project threshold (default 95%)
- **Watch Mode**: Use `vitest` or `vitest --watch` for development
- **CI Mode**: **CRITICAL** - Default `npm test` command MUST include `--run` flag
  - This prevents Vitest from entering watch mode, which never terminates
  - In `package.json`: `"test": "vitest --run"`
  - In CI workflows: use `npm test` (do NOT add `--run` argument)
  - For manual development, use `npm run test:watch`

Example test structure:
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { myFunction } from './my-module';

describe('myFunction', () => {
  beforeEach(() => {
    // Setup
  });

  afterEach(() => {
    // Cleanup
  });

  it('should handle valid input', () => {
    const result = myFunction('input');
    expect(result).toBe('expected');
  });

  it('should throw on invalid input', () => {
    expect(() => myFunction('')).toThrow('Invalid input');
  });
});
```

## Package Management

**CRITICAL**: Use consistent package manager across team.

- **Default**: npm (most compatible, built-in)
- **Alternative**: pnpm (fast, disk-efficient) or yarn
- **Lockfile**: Always commit lockfile (`package-lock.json`, `pnpm-lock.yaml`, or `yarn.lock`)
- **Workspaces**: Use for monorepos
- **CI/CD**: Update GitHub Actions workflows to match your package manager (see workflow comments)

### Dependencies

1. **Check for latest versions**:
   - Use Context7 MCP tool if available
   - Check npm registry: `npm view <package> versions`
   - Review changelog for breaking changes

2. **Dependency Guidelines**:
   - ‚úÖ Use exact versions for applications (`"1.2.3"`)
   - ‚úÖ Use semver for libraries (`"^1.2.3"`)
   - ‚úÖ Keep dependencies updated regularly
   - ‚úÖ Use `npm audit` or `pnpm audit` for security
   - ‚ùå Don't use deprecated packages
   - ‚ùå Don't add unnecessary dependencies

3. **Document new dependencies**:
   - Update CHANGELOG.md
   - Document why dependency was added
   - Note any peer dependencies

## Type Safety

- **No `any`**: Avoid `any` type - use `unknown` and type guards
- **Strict null checks**: Handle null/undefined explicitly
- **Type assertions**: Minimize use of `as` - prefer type guards
- **Generics**: Use for reusable type-safe code

Example type-safe code:
```typescript
// Good: Type guard
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function process(input: unknown): string {
  if (isString(input)) {
    return input.toUpperCase();
  }
  throw new Error('Invalid input');
}

// Bad: Type assertion
function processUnsafe(input: unknown): string {
  return (input as string).toUpperCase(); // Runtime error if not string
}
```

## Error Handling

- Create custom error classes
- Use type guards for error checking
- Document errors in JSDoc/TSDoc
- Never swallow errors silently

Example:
```typescript
export class ValidationError extends Error {
  constructor(
    message: string,
    public readonly field: string
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export function validate(data: unknown): Data {
  if (!isValidData(data)) {
    throw new ValidationError('Invalid data structure', 'data');
  }
  return data;
}
```

## Documentation

- **JSDoc/TSDoc**: Document public APIs
- **Examples**: Include usage examples
- **Type exports**: Export types for library consumers
- **README**: Include API documentation

Example:
```typescript
/**
 * Processes the input data and returns a formatted result.
 *
 * @param input - The input string to process
 * @param options - Optional processing options
 * @returns The processed string in uppercase
 * @throws {ValidationError} If input is empty
 *
 * @example
 * ```typescript
 * const result = process('hello', { trim: true });
 * console.log(result); // 'HELLO'
 * ```
 */
export function process(
  input: string,
  options?: ProcessOptions
): string {
  // Implementation
}
```

## Project Structure

```
project/
‚îú‚îÄ‚îÄ package.json        # Package manifest
‚îú‚îÄ‚îÄ tsconfig.json       # TypeScript config
‚îú‚îÄ‚îÄ vitest.config.ts    # Test config
‚îú‚îÄ‚îÄ README.md           # Project overview (allowed in root)
‚îú‚îÄ‚îÄ CHANGELOG.md        # Version history (allowed in root)
‚îú‚îÄ‚îÄ AGENTS.md          # AI assistant rules (allowed in root)
‚îú‚îÄ‚îÄ LICENSE            # Project license (allowed in root)
‚îú‚îÄ‚îÄ CONTRIBUTING.md    # Contribution guidelines (allowed in root)
‚îú‚îÄ‚îÄ CODE_OF_CONDUCT.md # Code of conduct (allowed in root)
‚îú‚îÄ‚îÄ SECURITY.md        # Security policy (allowed in root)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts        # Main entry point
‚îÇ   ‚îú‚îÄ‚îÄ types.ts        # Type definitions
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ tests/              # Test files
‚îú‚îÄ‚îÄ dist/               # Compiled output (gitignored)
‚îî‚îÄ‚îÄ docs/               # Project documentation
```

## Module System

- Use ES modules (`import`/`export`)
- Set `"type": "module"` in `package.json`
- Use `.js` extensions in imports for Node.js compatibility
- Configure `moduleResolution: "node"` in tsconfig.json

Example:
```typescript
// Good: ES modules with .js extension
import { myFunction } from './my-module.js';

export { myFunction };
export default class MyClass {}
```

## CI/CD Requirements

**CRITICAL**: GitHub Actions `cache: 'npm'` requires `package-lock.json` to be committed.

- **Lockfile Requirement**: Remove `package-lock.json` from `.gitignore`
- **Cache Strategy**: Use `cache: 'npm'` in `setup-node` action
- **Install Command**: Use `npm ci` (not `npm install`) for reproducible builds
- **Error Prevention**: Without committed lockfile, you'll get:
  ```
  Error: Dependencies lock file is not found in repository
  Supported file patterns: package-lock.json,npm-shrinkwrap.json,yarn.lock
  ```

Must include GitHub Actions workflows for:

1. **Testing** (`typescript-test.yml`):
   - Test on ubuntu-latest, windows-latest, macos-latest
   - Use Vitest for fast execution
   - Upload coverage reports
   - **MUST**: Commit package-lock.json for caching

2. **Linting** (`typescript-lint.yml`):
   - Type check: `tsc --noEmit`
   - ESLint: `eslint src/**/*.ts`
   - Prettier: `prettier --check "src/**/*.ts"`
   - **MUST**: Commit package-lock.json for caching

3. **Build** (`typescript-build.yml`):
   - Build: `npm run build`
   - Verify no type errors
   - Check output artifacts
   - **MUST**: Commit package-lock.json for caching

## Package Publication

### Publishing to npm

**Prerequisites:**
1. Create npm account at https://www.npmjs.com
2. Generate npm token (Account Settings ‚Üí Access Tokens ‚Üí Generate New Token)
3. Add `NPM_TOKEN` to GitHub repository secrets

**package.json Configuration:**

```json
{
  "name": "@your-org/package-name",
  "version": "1.0.0",
  "description": "Package description",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "scripts": {
    "prepublishOnly": "npm run build && npm test"
  },
  "keywords": ["your", "keywords"],
  "author": "Your Name",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/your-org/package-name"
  }
}
```

**Publishing Workflow:**

1. Update version: `npm version patch|minor|major`
2. Create release tag: `git push --tags`
3. GitHub Actions automatically publishes to npm
4. Or manual publish: `npm publish --access public`

**Publishing Checklist:**

- ‚úÖ All tests passing
- ‚úÖ Code linted and formatted
- ‚úÖ Version updated in package.json
- ‚úÖ CHANGELOG.md updated
- ‚úÖ README.md up to date
- ‚úÖ Type declarations generated
- ‚úÖ Package size reasonable (`npm pack` to check)
- ‚úÖ .npmignore or package.json "files" configured
- ‚úÖ Provenance enabled for security

**npm Provenance:**

Enable provenance for better security and transparency:
```bash
npm publish --provenance --access public
```

This links your package to its source code and build process.

<!-- TYPESCRIPT:END -->



<!-- AGENT_AUTOMATION:START -->
# Agent Automation Rules

**CRITICAL**: Mandatory workflow that AI agents MUST execute after EVERY implementation.

## Workflow Overview

After completing ANY feature, bug fix, or code change, execute this workflow in order:

### Step 1: Quality Checks (MANDATORY)

Run these checks in order - ALL must pass:

```bash
1. Type check (if applicable)
2. Lint (MUST pass with ZERO warnings)
3. Format code
4. Run ALL tests (MUST pass 100%)
5. Verify coverage meets threshold (default 95%)
```

**Language-specific commands**: See your language template (TYPESCRIPT, RUST, PYTHON, etc.) for exact commands.

**IF ANY CHECK FAILS:**
- ‚ùå STOP immediately
- ‚ùå DO NOT proceed
- ‚ùå DO NOT commit
- ‚úÖ Fix the issue first
- ‚úÖ Re-run ALL checks

### Step 2: Security & Dependency Audits

```bash
# Check for vulnerabilities (language-specific)
# Check for outdated dependencies (informational)
# Find unused dependencies (optional)
```

**Language-specific commands**: See your language template for audit commands.

**IF VULNERABILITIES FOUND:**
- ‚úÖ Attempt automatic fix
- ‚úÖ Document if auto-fix fails
- ‚úÖ Include in Step 5 report
- ‚ùå Never ignore critical/high vulnerabilities without user approval

### Step 3: Update OpenSpec Tasks

If `openspec/` directory exists:

```bash
# Mark completed tasks as [DONE]
# Update in-progress tasks
# Add new tasks if discovered
# Update progress percentages
# Document deviations or blockers
```

### Step 4: Update Documentation

```bash
# Update ROADMAP.md (if feature is milestone)
# Update CHANGELOG.md (conventional commits format)
# Update feature specs (if implementation differs)
# Update README.md (if public API changed)
```

### Step 5: Git Commit

**ONLY after ALL above steps pass:**

```bash
git add .
git commit -m "<type>(<scope>): <description>

- Detailed change 1
- Detailed change 2
- Tests: [describe coverage]
- Coverage: X% (threshold: 95%)

Closes #<issue> (if applicable)"
```

**Commit Types**: `feat`, `fix`, `docs`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`

### Step 6: Report to User

```
‚úÖ Implementation Complete

üìù Changes:
- [List main changes]

üß™ Quality Checks:
- ‚úÖ Type check: Passed
- ‚úÖ Linting: Passed (0 warnings)
- ‚úÖ Formatting: Applied
- ‚úÖ Tests: X/X passed (100%)
- ‚úÖ Coverage: X% (threshold: 95%)

üîí Security:
- ‚úÖ No vulnerabilities

üìä OpenSpec:
- ‚úÖ Tasks updated
- ‚úÖ Progress: X% ‚Üí Y%

üìö Documentation:
- ‚úÖ CHANGELOG.md updated
- ‚úÖ [other docs updated]

üíæ Git:
- ‚úÖ Committed: <commit message>
- ‚úÖ Hash: <commit hash>

üìã Next Steps:
- [ ] Review changes
- [ ] Push to remote (if ready)
```

## Automation Exceptions

Skip steps ONLY when:

1. **Exploratory Code**: User says "experimental", "draft", "try"
   - Still run quality checks
   - Don't commit

2. **User Explicitly Requests**: User says "skip tests", "no commit"
   - Only skip requested step
   - Warn about skipped steps

3. **Emergency Hotfix**: Critical production bug
   - Run minimal checks
   - Document technical debt

**In ALL other cases: Execute complete workflow**

## Error Recovery

If workflow fails 3+ times:

```bash
1. Create backup branch
2. Reset to last stable commit
3. Report to user with error details
4. Request guidance or try alternative approach
```

## Best Practices

### DO's ‚úÖ
- ALWAYS run complete workflow
- ALWAYS update OpenSpec and documentation
- ALWAYS use conventional commits
- ALWAYS report summary to user
- ASK before skipping steps

### DON'Ts ‚ùå
- NEVER skip quality checks without permission
- NEVER commit failing tests
- NEVER commit linting errors
- NEVER skip documentation updates
- NEVER assume user wants to skip automation
- NEVER commit debug code or secrets

## Summary

**Complete workflow after EVERY implementation:**

1. ‚úÖ Quality checks (type, lint, format, test, coverage)
2. ‚úÖ Security audit
3. ‚úÖ Update OpenSpec tasks
4. ‚úÖ Update documentation
5. ‚úÖ Git commit (conventional format)
6. ‚úÖ Report summary to user

**Only skip with explicit user permission and document why.**

<!-- AGENT_AUTOMATION:END -->


<!-- GIT:START -->

**AI Assistant Git Push Mode**: MANUAL

**CRITICAL**: Never execute `git push` commands automatically.
Always provide push commands for manual execution by the user.

Example:
```
‚úã MANUAL ACTION REQUIRED:
Run these commands manually (SSH password may be required):
  git push origin main
  git push origin v1.0.0
```

# Git Workflow Rules

**CRITICAL**: Specific rules and patterns for Git version control workflow.

## Git Workflow Overview

This project follows a strict Git workflow to ensure code quality and proper version control.

**NEVER commit code without tests passing. NEVER create tags without full quality checks.**

## Initial Repository Setup

### New Project Initialization

**‚ö†Ô∏è CRITICAL**: Only run initialization commands if `.git` directory does NOT exist!

```bash
# Check if Git repository already exists
if [ -d .git ]; then
  echo "‚ùå Git repository already initialized. Skipping git init."
  echo "Current status:"
  git status
  git remote -v
  exit 0
fi

# If no .git directory exists, initialize:

# Initialize Git repository
git init

# Add all files
git add .

# Initial commit
git commit -m "chore: Initial project setup"

# Rename default branch to main (GitHub standard)
git branch -M main

# Add remote (if applicable)
git remote add origin <repository-url>
```

**AI Assistant Behavior:**

```
BEFORE running any Git initialization commands:

1. Check if .git directory exists
2. If exists:
   ‚úÖ Repository already configured
   ‚ùå DO NOT run: git init
   ‚ùå DO NOT run: git branch -M main
   ‚úÖ Check status: git status
   ‚úÖ Show remotes: git remote -v
   
3. If not exists:
   ‚úÖ Safe to initialize
   ‚úÖ Run full initialization sequence
```

## AI Assistant Git Checks

**CRITICAL**: AI assistants MUST perform these checks before Git operations:

### Automatic Checks

```bash
# 1. Check if Git repository exists
if [ ! -d .git ]; then
  echo "No Git repository found."
  # Ask user if they want to initialize
fi

# 2. Check if there are unstaged changes
git status --short

# 3. Check current branch
CURRENT_BRANCH=$(git branch --show-current)
echo "On branch: $CURRENT_BRANCH"

# 4. Check if remote exists
git remote -v

# 5. Check for unpushed commits
git log origin/main..HEAD --oneline 2>/dev/null
```

### Before Git Commands

**NEVER execute if `.git` directory exists:**
- ‚ùå `git init` - Repository already initialized
- ‚ùå `git branch -M main` - Branch may already be configured
- ‚ùå `git remote add origin` - Remote may already exist (check first with `git remote -v`)
- ‚ùå `git config user.name/email` - User configuration is personal
- ‚ùå Reconfiguration commands - Repository is already set up

**ALWAYS safe to execute:**
- ‚úÖ `git status` - Check repository state
- ‚úÖ `git add` - Stage changes
- ‚úÖ `git commit` - Create commits (after quality checks)
- ‚úÖ `git log` - View history
- ‚úÖ `git diff` - View changes
- ‚úÖ `git branch` - List branches
- ‚úÖ `git tag` - Create tags (after quality checks)

**Execute with caution (check first):**
- ‚ö†Ô∏è `git push` - Follow push mode configuration
- ‚ö†Ô∏è `git pull` - May cause merge conflicts
- ‚ö†Ô∏è `git merge` - May cause conflicts
- ‚ö†Ô∏è `git rebase` - Can rewrite history
- ‚ö†Ô∏è `git reset --hard` - Destructive, only for rollback
- ‚ö†Ô∏è `git push --force` - NEVER on main/master

### Repository Detection

**AI Assistant MUST check:**

```bash
# Before ANY Git operation:

# 1. Does .git exist?
if [ -d .git ]; then
  echo "‚úÖ Git repository exists"
  
  # 2. Check current state
  git status
  
  # 3. Check branch
  BRANCH=$(git branch --show-current)
  echo "On branch: $BRANCH"
  
  # 4. Check remote
  REMOTE=$(git remote -v)
  if [ -z "$REMOTE" ]; then
    echo "‚ö†Ô∏è  No remote configured"
  else
    echo "Remote: $REMOTE"
  fi
  
  # 5. Proceed with normal Git operations
else
  echo "‚ö†Ô∏è  No Git repository found"
  echo "Ask user if they want to initialize Git"
fi
```

## Daily Development Workflow

### 1. Before Making Changes

**CRITICAL**: Always check current state:

```bash
# Check current branch and status
git status

# Ensure you're on the correct branch
git branch

# Pull latest changes if working with team (use --ff-only for safety)
git pull --ff-only origin main
```

**Git Safety**: Use `--ff-only` to prevent unexpected merge commits and maintain linear history.

### 2. Making Changes

**CRITICAL**: Commit after every important implementation:

```bash
# After implementing a feature/fix:

# 1. Run ALL quality checks FIRST
npm run lint           # or equivalent for your language
npm run type-check     # TypeScript/typed languages
npm test              # ALL tests must pass
npm run build         # Ensure build succeeds

# 2. If ALL checks pass, stage changes
git add .

# 3. Commit with conventional commit message
git commit -m "feat: Add user authentication

- Implement login/logout functionality
- Add JWT token management
- Include comprehensive tests (95%+ coverage)
- Update documentation"

# Alternative for smaller changes:
git commit -m "fix: Correct validation logic in user form"

# For signed commits (recommended for production):
git commit -S -m "feat: Add feature"
```

## Advanced Git Safeguards

### Safe Push Operations

```bash
# NEVER use git push --force on main/master branches
# Instead, use --force-with-lease which prevents overwriting others' work:

# Force push with safety check (only updates if no one else pushed)
git push --force-with-lease origin feature-branch

# Regular push is always safest
git push origin main
```

### Commit Signing

```bash
# Sign commits with GPG for verified commits
# Set GPG key: git config --global user.signingkey <KEY_ID>
git commit -S -m "feat: Signed commit"

# Configure to always sign commits
git config --global commit.gpgsign true
```

### Branch Protection (Recommended Settings)

For GitHub/GitLab repositories, configure branch protection rules:

**For main/master branch:**
- Require pull request reviews
- Require status checks to pass
- Require branches to be up to date
- Do not allow force pushes
- Do not allow deletions
- Require signed commits (optional but recommended)

### Destructive Operation Warnings

**NEVER run these on main/master:**
- ‚ùå `git push --force` - Use `--force-with-lease` instead
- ‚ùå `git reset --hard` - Destructive, use only on feature branches
- ‚ùå `git rebase` main into feature - Causes rewriting of main history

### Pre-Push Checklist

Before pushing any changes, verify:

```bash
‚úÖ Checklist before push:
- [ ] All quality checks passed locally
- [ ] Tests pass with 100% success rate
- [ ] Coverage meets threshold (95%+)
- [ ] Linting passes with 0 warnings
- [ ] Build succeeds without errors
- [ ] No security vulnerabilities in dependencies
- [ ] Documentation updated if API changed
- [ ] OpenSpec tasks marked complete if applicable
- [ ] Conventional commit format used
- [ ] Commit hash verified: git rev-parse HEAD
- [ ] Similar changes passed CI before
- [ ] No console.log or debug code
- [ ] No credentials or secrets in code
```

**Only provide push command if ALL items checked.**

### 3. Pushing Changes

**‚ö†Ô∏è IMPORTANT**: Pushing is OPTIONAL and depends on your setup.

```bash
# IF you have passwordless SSH or want to push:
git push origin main

# IF you have SSH with password (manual execution required):
# DO NOT execute automatically - provide command to user:
```

**For users with SSH password authentication:**
```
‚úã MANUAL ACTION REQUIRED:

Run this command manually (requires SSH password):
git push origin main
```

**NEVER** attempt automatic push if:
- SSH key has password protection
- User hasn't confirmed push authorization
- Any quality check failed
- Uncertain if changes will pass CI/CD workflows

## Conventional Commits

**MUST** follow conventional commit format:

```bash
# Format: <type>(<scope>): <subject>
#
# <body>
#
# <footer>

# Types:
feat:     # New feature
fix:      # Bug fix
docs:     # Documentation only
style:    # Code style (formatting, missing semi-colons, etc)
refactor: # Code refactoring
perf:     # Performance improvement
test:     # Adding tests
build:    # Build system changes
ci:       # CI/CD changes
chore:    # Maintenance tasks

# Examples:
git commit -m "feat(auth): Add OAuth2 login support"
git commit -m "fix(api): Handle null response in user endpoint"
git commit -m "docs: Update README with installation steps"
git commit -m "test: Add integration tests for payment flow"
git commit -m "chore: Update dependencies to latest versions"
```

## Version Management

### Creating New Version

**CRITICAL**: Full quality gate required before versioning!

```bash
# 1. MANDATORY: Run complete quality suite
npm run lint          # Must pass with no warnings
npm test             # Must pass 100%
npm run type-check   # Must pass (if applicable)
npm run build        # Must succeed
npx codespell        # Must pass (if configured)

# 2. Update version in package.json/Cargo.toml/etc
# Use semantic versioning:
# - MAJOR: Breaking changes (1.0.0 -> 2.0.0)
# - MINOR: New features, backwards compatible (1.0.0 -> 1.1.0)
# - PATCH: Bug fixes (1.0.0 -> 1.0.1)

# 3. Update CHANGELOG.md
# Document all changes in this version:
## [1.2.0] - 2024-01-15
### Added
- New feature X
- New feature Y

### Fixed
- Bug in component Z

### Changed
- Refactored module A

# 4. Commit version changes
git add .
git commit -m "chore: Release version 1.2.0

- Updated version to 1.2.0
- Updated CHANGELOG.md with release notes"

# 5. Create annotated tag
git tag -a v1.2.0 -m "Release version 1.2.0

Major changes:
- Feature X
- Feature Y
- Bug fix Z

All tests passing ‚úÖ
Coverage: 95%+ ‚úÖ
Linting: Clean ‚úÖ
Build: Success ‚úÖ"

# 6. OPTIONAL: Push tag (manual if SSH password)
# Only if you're CERTAIN it will pass CI/CD workflows!
```

**For users requiring manual push:**
```
‚úã MANUAL ACTIONS REQUIRED:

1. Verify all quality checks passed locally
2. Push commits:
   git push origin main

3. Push tag:
   git push origin v1.2.0

Note: Tag push will trigger CI/CD workflows and may create GitHub release.
Only push if you're confident all checks will pass.
```

## Quality Gate Enforcement

**CRITICAL**: Pre-commit checks MUST match GitHub Actions workflow commands to prevent CI/CD failures.

### Language-Specific Pre-Commit Commands

**The commands you run locally MUST be identical to those in your GitHub Actions workflows.**

#### TypeScript/JavaScript Projects

```bash
# These commands MUST match .github/workflows/*.yml

# 1. Type check (matches workflow)
npm run type-check        # Must match workflow exactly

# 2. Lint (matches workflow)
npm run lint              # Must match workflow exactly

# 3. Format check (matches workflow)
npx prettier --check 'src/**/*.ts' 'tests/**/*.ts'  # Must match workflow

# 4. Tests (matches workflow)
npm test                  # Must match workflow exactly

# 5. Build (matches workflow)
npm run build             # Must match workflow exactly

# If ANY fails: ‚ùå DO NOT COMMIT - Fix first!
```

#### Rust Projects

```bash
# These commands MUST match .github/workflows/*.yml

# 1. Format check (matches workflow)
cargo fmt --all -- --check

# 2. Clippy (matches workflow)
cargo clippy --all-targets --all-features -- -D warnings

# 3. Tests (matches workflow)
cargo test --all-features

# 4. Build (matches workflow)
cargo build --release

# If ANY fails: ‚ùå DO NOT COMMIT - Fix first!
```

#### Python Projects

```bash
# These commands MUST match .github/workflows/*.yml

# 1. Format check (matches workflow)
black --check .

# 2. Lint (matches workflow)
ruff check .

# 3. Type check (matches workflow)
mypy .

# 4. Tests (matches workflow)
pytest

# If ANY fails: ‚ùå DO NOT COMMIT - Fix first!
```

### Before ANY Commit

**MANDATORY CHECKS**:

```bash
# Checklist - ALL must pass:
‚òê Code formatted
‚òê Linter passes (no warnings)
‚òê Type check passes
‚òê ALL tests pass (100%)
‚òê Coverage meets threshold (95%+)
‚òê Build succeeds
‚òê No console errors/warnings

# Run quality check script:
npm run quality-check  # or equivalent

# If ANY check fails:
# ‚ùå DO NOT COMMIT
# ‚ùå FIX THE ISSUES FIRST
```

### Before Tag Creation

**MANDATORY CHECKS** (even stricter):

```bash
# Extended checklist - ALL must pass:
‚òê All pre-commit checks passed
‚òê Codespell passes (no typos)
‚òê Security audit clean
‚òê Dependencies up to date
‚òê Documentation updated
‚òê CHANGELOG.md updated
‚òê Version bumped correctly
‚òê All workflows would pass

# Run comprehensive check:
npm run lint
npm test
npm run type-check
npm run build
npx codespell
npm audit

# Only create tag if everything is green!
```

## Error Recovery & Rollback

### When Implementation Is Failing

If the AI is making repeated mistakes and user is frustrated:

```bash
# 1. Identify last stable commit
git log --oneline -10

# 2. Create backup branch of current work
git branch backup-failed-attempt

# 3. Hard reset to last stable version
git reset --hard <last-stable-commit-hash>

# 4. Verify stability
npm test
npm run build

# 5. Reimplement from scratch using DIFFERENT approach
# ‚ö†Ô∏è DO NOT repeat the same techniques that failed before
# ‚ö†Ô∏è Review AGENTS.md for alternative patterns
# ‚ö†Ô∏è Consider different architecture/design

# 6. After successful reimplementation
git branch -D backup-failed-attempt  # Delete backup if no longer needed
```

### Undo Last Commit (Not Pushed)

```bash
# Keep changes, undo commit
git reset --soft HEAD~1

# Discard changes completely
git reset --hard HEAD~1
```

### Revert Pushed Commit

```bash
# Create revert commit
git revert <commit-hash>

# Then push (manual if SSH password)
```

## Branch Strategy

### Feature Branches

```bash
# Create feature branch
git checkout -b feature/user-authentication

# Work on feature...
# Commit regularly with quality checks

# When feature complete and tested:
git checkout main
git merge feature/user-authentication

# Delete feature branch
git branch -d feature/user-authentication
```

### Hotfix Workflow

```bash
# Critical bug in production
git checkout -b hotfix/critical-security-fix

# Fix the bug
# MUST include tests
# MUST pass all quality checks

git commit -m "fix: Critical security vulnerability in auth

- Patch authentication bypass
- Add regression tests
- Update security documentation"

# Merge to main
git checkout main
git merge hotfix/critical-security-fix

# Tag immediately if production fix
git tag -a v1.2.1 -m "Hotfix: Security patch"

# Manual push if required
```

## CRITICAL RESTRICTIONS - HUMAN AUTHORIZATION REQUIRED

**‚ö†Ô∏è IMPERATIVE RULES - THESE ARE NON-NEGOTIABLE ‚ö†Ô∏è**

### Destructive Git Operations

**ABSOLUTELY FORBIDDEN without explicit human authorization:**

```
‚ùå NEVER execute: git checkout
   ‚úã ALWAYS ask user: "Do you want to checkout [branch/commit]? [Y/n]"
   ‚úÖ Only execute after explicit user confirmation
   
‚ùå NEVER execute: git reset
   ‚úã ALWAYS ask user: "Do you want to reset to [commit]? This may lose changes. [Y/n]"
   ‚úÖ Only execute after explicit user confirmation
   ‚ö†Ô∏è  Explain consequences before executing
```

**Rationale**: These commands can cause data loss. Human oversight is mandatory.

### Merge Conflict Resolution

**When merge conflicts occur:**

```
‚ùå NEVER attempt to resolve conflicts by editing files automatically
‚ùå NEVER commit merged files without human review
‚úÖ ALWAYS stop and request human assistance
‚úÖ ALWAYS provide conflict locations and context
‚úÖ ALWAYS wait for human to resolve manually

Message to user:
"‚ö†Ô∏è Merge conflict detected in the following files:
- [list of conflicted files]

Please resolve these conflicts manually. I cannot auto-resolve merge conflicts.

To resolve:
1. Open the conflicted files
2. Look for conflict markers (<<<<<<<, =======, >>>>>>>)
3. Choose the correct version or merge manually
4. Remove conflict markers
5. Run: git add <resolved-files>
6. Run: git commit

Let me know when you're done, and I can help with the next steps."
```

**Rationale**: Merge conflicts require human judgment about which code to keep.

### Commit Frequency Management

**‚ö†Ô∏è IMPORTANT: Reduce excessive commits**

```
‚ùå DO NOT commit after every small change
‚ùå DO NOT create multiple commits for the same logical feature
‚úÖ COMMIT only when:
   - A complete feature is implemented and tested
   - A significant bug fix is completed
   - A major refactoring is done
   - Before creating a version tag
   - User explicitly requests a commit
   
‚úÖ GROUP related changes into meaningful commits
‚úÖ USE conventional commit messages that describe the full scope

Example of GOOD commit frequency:
- Implement entire authentication system ‚Üí 1 commit
- Add login, logout, and session management ‚Üí 1 commit
- Complete feature with tests and docs ‚Üí 1 commit

Example of BAD commit frequency (AVOID):
- Add login function ‚Üí commit
- Add logout function ‚Üí commit  
- Add session check ‚Üí commit
- Fix typo ‚Üí commit
- Update comment ‚Üí commit
```

**Rationale**: Too many commits pollute git history and make it harder to track meaningful changes.

### Feature Branch Strategy

**BEFORE starting ANY new task or feature:**

```
‚úã ALWAYS ask user FIRST:
"Should I create a separate branch for this feature/task? [Y/n]

Options:
1. Create feature branch: git checkout -b feature/[name]
2. Work directly on current branch
3. Create hotfix branch: git checkout -b hotfix/[name]

What would you prefer?"

‚úÖ Wait for user decision
‚úÖ Respect user's branching strategy
‚ùå NEVER assume to work on main without asking
‚ùå NEVER create branches without permission

If user says YES to branch:
  ‚Üí Create branch with descriptive name
  ‚Üí Work on that branch
  ‚Üí Ask before merging back to main
  
If user says NO to branch:
  ‚Üí Proceed on current branch
  ‚Üí Be extra careful with commits
```

**Rationale**: Branching strategy varies by team and project. Always confirm with the human first.

## Critical AI Assistant Rules

### Repository Initialization

**BEFORE any `git init` or setup commands:**

```
1. Check for .git directory existence
2. If .git exists:
   - ‚ùå STOP - Repository already configured
   - ‚ùå DO NOT run git init
   - ‚ùå DO NOT run git config
   - ‚ùå DO NOT run git branch -M
   - ‚ùå DO NOT reconfigure anything
   - ‚úÖ Use existing repository as-is
   
3. If .git does NOT exist:
   - ‚úÖ Ask user if they want Git initialization
   - ‚úÖ Run initialization sequence if approved
```

### Push Command Behavior

**Based on configured push mode:**

```
Manual Mode (DEFAULT):
  ‚ùå NEVER execute: git push
  ‚úÖ ALWAYS provide: "Run manually: git push origin main"
  
Prompt Mode:
  ‚ö†Ô∏è  ALWAYS ask first: "Ready to push. Proceed? [Y/n]"
  ‚úÖ Execute only if user confirms
  
Auto Mode:
  ‚ö†Ô∏è  Check quality first
  ‚ö†Ô∏è  Only if 100% confident
  ‚úÖ Execute if all checks passed
```

### Quality Gate Enforcement

**MANDATORY checks before commit:**

```bash
# Run in this exact order:
1. npm run lint          # or language equivalent
2. npm run type-check    # if applicable
3. npm test             # ALL tests must pass
4. npm run build        # must succeed

# If ANY fails:
‚ùå STOP - DO NOT commit
‚ùå Fix issues first
‚ùå Re-run all checks

# If ALL pass:
‚úÖ Safe to commit
‚úÖ Proceed with git add and commit
```

**MANDATORY checks before tag:**

```bash
# Extended checks for version tags:
1. All commit checks above +
2. npx codespell        # no typos
3. npm audit            # no vulnerabilities
4. CHANGELOG.md updated
5. Version bumped correctly
6. Documentation current

# If ANY fails:
‚ùå STOP - DO NOT create tag
‚ùå Fix issues
‚ùå Re-verify everything

# Only create tag if 100% green!
```

## Best Practices

### DO's ‚úÖ

- **ALWAYS** check if .git exists before init commands
- **ALWAYS** run tests before commit
- **ALWAYS** use conventional commit messages
- **ALWAYS** update CHANGELOG for versions
- **ALWAYS** ask before executing `git checkout`
- **ALWAYS** ask before executing `git reset`
- **ALWAYS** ask user if a feature branch should be created before starting tasks
- **ALWAYS** request human assistance when merge conflicts occur
- **COMMIT** only when complete features/fixes are done (not for every small change)
- **TAG** releases with semantic versions
- **VERIFY** quality gates before tagging
- **DOCUMENT** breaking changes clearly
- **REVERT** when implementation is failing repeatedly
- **ASK** user before automatic push
- **PROVIDE** manual commands for SSH password users
- **CHECK** repository state before operations
- **RESPECT** existing Git configuration
- **GROUP** related changes into meaningful commits

### DON'Ts ‚ùå

- **NEVER** run `git init` if .git exists
- **NEVER** run `git config` (user-specific)
- **NEVER** run `git checkout` without explicit user authorization
- **NEVER** run `git reset` without explicit user authorization
- **NEVER** auto-resolve merge conflicts by editing files
- **NEVER** commit merged files without human review
- **NEVER** create excessive commits for small changes
- **NEVER** assume branching strategy - always ask user first
- **NEVER** reconfigure existing repository
- **NEVER** commit without passing tests
- **NEVER** commit with linting errors
- **NEVER** commit with build failures
- **NEVER** create tag without quality checks
- **NEVER** push automatically with SSH password
- **NEVER** push if uncertain about CI/CD success
- **NEVER** commit console.log/debug code
- **NEVER** commit credentials or secrets
- **NEVER** force push to main/master
- **NEVER** rewrite published history
- **NEVER** skip hooks (--no-verify)
- **NEVER** assume repository configuration

## SSH Configuration

### For Users with SSH Password

If your SSH key has password protection:

**Configuration in AGENTS.md or project settings:**

```yaml
git_workflow:
  auto_push: false
  push_mode: "manual"
  reason: "SSH key has password protection"
```

**AI Assistant Behavior:**
- ‚úÖ Provide push commands in chat
- ‚úÖ Wait for user manual execution
- ‚ùå Never attempt automatic push
- ‚ùå Never execute git push commands

### For Users with Passwordless SSH

```yaml
git_workflow:
  auto_push: true  # or prompt each time
  push_mode: "auto"
```

## Git Hooks

### Pre-commit Hook

Create `.git/hooks/pre-commit`:

```bash
#!/bin/sh

echo "Running pre-commit checks..."

# Run linter
npm run lint
if [ $? -ne 0 ]; then
  echo "‚ùå Linting failed. Commit aborted."
  exit 1
fi

# Run tests
npm test
if [ $? -ne 0 ]; then
  echo "‚ùå Tests failed. Commit aborted."
  exit 1
fi

# Run type check (if applicable)
if command -v tsc &> /dev/null; then
  npm run type-check
  if [ $? -ne 0 ]; then
    echo "‚ùå Type check failed. Commit aborted."
    exit 1
  fi
fi

echo "‚úÖ All pre-commit checks passed!"
exit 0
```

### Pre-push Hook

Create `.git/hooks/pre-push`:

```bash
#!/bin/sh

echo "Running pre-push checks..."

# Run full test suite
npm test
if [ $? -ne 0 ]; then
  echo "‚ùå Tests failed. Push aborted."
  exit 1
fi

# Run build
npm run build
if [ $? -ne 0 ]; then
  echo "‚ùå Build failed. Push aborted."
  exit 1
fi

echo "‚úÖ All pre-push checks passed!"
exit 0
```

Make hooks executable:
```bash
chmod +x .git/hooks/pre-commit
chmod +x .git/hooks/pre-push
```

## CI/CD Integration

### Before Providing Push Commands

**CRITICAL**: Only suggest push if confident about CI/CD success:

```
‚úÖ Provide push command if:
- All local tests passed
- All linting passed
- Build succeeded
- Coverage meets threshold
- No warnings or errors
- Code follows AGENTS.md standards
- Similar changes passed CI/CD before

‚ùå DO NOT provide push command if:
- ANY quality check failed
- Uncertain about CI/CD requirements
- Making experimental changes
- First time working with this codebase
- User seems uncertain

Instead say:
"I recommend running the full CI/CD pipeline locally first to ensure 
the changes will pass. Once confirmed, you can push manually."
```

## GitHub MCP Server Integration

**If GitHub MCP Server is available**, use it for automated workflow monitoring.

### Workflow Validation After Push

```
After every git push (manual or auto):

1. Wait 5-10 seconds for workflows to trigger

2. Check workflow status via GitHub MCP:
   - List workflow runs for latest commit
   - Check status of each workflow

3. If workflows are RUNNING:
   ‚è≥ Report: "CI/CD workflows in progress..."
   ‚úÖ Continue with other tasks
   ‚úÖ Check again in next user interaction
   
4. If workflows COMPLETED:
   - All passed: ‚úÖ Report success
   - Some failed: ‚ùå Fetch errors and fix

5. If workflows FAILED:
   a. Fetch complete error logs via GitHub MCP
   b. Display errors to user
   c. Analyze against AGENTS.md standards
   d. Propose specific fixes
   e. Implement fixes
   f. Run local quality checks
   g. Commit fixes
   h. Provide push command for retry
```

### Next Interaction Check

```
On every user message after a push:

if (github_mcp_available && last_push_timestamp) {
  // Check workflow status
  const status = await checkWorkflows();
  
  if (status.running) {
    console.log('‚è≥ CI/CD still running, will check later');
  } else if (status.failed) {
    console.log('‚ùå CI/CD failures detected!');
    await analyzeAndFixErrors(status.errors);
  } else {
    console.log('‚úÖ All CI/CD workflows passed!');
  }
}
```

### Error Analysis Flow

```
When workflow fails:

1. Fetch error via GitHub MCP:
   - Workflow name
   - Job name  
   - Failed step
   - Error output
   - Full logs

2. Categorize error:
   - Test failure ‚Üí Fix test or implementation
   - Lint error ‚Üí Format/fix code style
   - Build error ‚Üí Fix compilation issues
   - Type error ‚Üí Fix type definitions
   - Coverage error ‚Üí Add more tests

3. Fix following AGENTS.md:
   - Apply correct pattern from AGENTS.md
   - Add tests if needed
   - Verify locally before committing

4. Commit fix:
   git commit -m "fix: Resolve CI/CD failure - [specific issue]"

5. Provide push command:
   "Ready to retry. Run: git push origin main"

6. After next push:
   - Monitor again
   - Verify fix worked
```

### CI/CD Confidence Check

**Before suggesting push:**

```
Assess confidence in CI/CD success:

HIGH confidence (safe to push):
‚úÖ All local checks passed
‚úÖ Similar changes passed CI before
‚úÖ No experimental changes
‚úÖ Follows AGENTS.md exactly
‚úÖ Comprehensive tests
‚úÖ No unusual patterns

MEDIUM confidence (verify first):
‚ö†Ô∏è First time with this pattern
‚ö†Ô∏è Modified build configuration
‚ö†Ô∏è Changed dependencies
‚ö†Ô∏è Cross-platform concerns
‚Üí Suggest: "Let's verify locally first"

LOW confidence (don't push yet):
‚ùå Experimental implementation
‚ùå Skipped some tests
‚ùå Uncertain about compatibility
‚ùå Modified CI/CD files
‚Üí Say: "Let's run additional checks first"
```

## Troubleshooting

### Merge Conflicts

```bash
# View conflicts
git status

# Edit conflicted files (marked with <<<<<<<, =======, >>>>>>>)

# After resolving:
git add <resolved-files>
git commit -m "fix: Resolve merge conflicts"
```

### Accidental Commit

```bash
# Undo last commit, keep changes
git reset --soft HEAD~1

# Make corrections
# Re-commit properly
```

### Lost Commits

```bash
# View all actions
git reflog

# Recover lost commit
git checkout <commit-hash>
git checkout -b recovery-branch
```

<!-- GIT:END -->
